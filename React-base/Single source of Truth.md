В управлении состоянием есть такое понятие как Единый источник истины — **Single Source of Truth.** Что оно означает. В компоненте могут использоваться данные из разных источников. Если их пытаться использовать для одной цели — для вывода одной и той же информации, например, то у нас могут возникнуть проблемы. Различные источники данных могут обновляться несинхронно, что приводит к получению неконсистентных данных в этих источниках. Мы уже касались этого термина, неконсистентные — значит не соответствующие друг другу. Как следствие, получим крайне сложную поддержку кода и кучу багов в придачу. Как понимаете — оно нам не нужно.

Чтобы избежать проблем, нужно придерживаться единого источника истины, то есть для вывода одной и той же информации всегда использовать только один источник. Посмотрим на приме
```javascript
// ---- файл App.js ----
import { useState } from 'react';
import { Counter } from './components/Counter';
import styles from './App.module.css';

const App = () => {
	const [value, setValue] = useState(0);

    return (
        <div className={styles.app}>
            <label>Счётчик ({value}):</label>
            <Counter value={value} onSetValue={setValue} />
        </div>
    );
}

export default App;
```

```javascript

// ---- файл /components/Counter.js ----
import { useState } from 'react';

export const Counter = ({ value, onSetValue }) => {
	const [counterValue, setCounterValue] = useState(value);

	return (
		<>
			<div>{counterValue}</div>
			<button onClick={() => onSetValue(value + 1)}>{value} + 1</button>
		</>
	);
};
```

В компоненте Counter есть 2 источника истины для одной и той же информации — значения счётчика. Это currentValue из собственного состояния и value из пропсов, переданное из состояния родителя.

Одно значение отображаем над кнопкой, а второе — на самой кнопке. Попробуем понажимать кнопку и увидим, что значения отличаются. Причина в том, что хук useState() обрабатывает переданное значение только при инициализации компонента. Во время рендера, который будет происходить при изменении пропа value — useState() возвращает то значение, которое он запомнил и которое менялось только с помощью функции-сеттера setCounterValue(). А эту функцию мы нигде не вызываем, поэтому значение там и не меняется.

Даже на таком элементарном примере уже можно запутаться — что, откуда, куда и как связано. Поэтому нельзя допускать, чтобы источников одной и той же информации было несколько. Источник истины должен быть один. Из двух состояний выбираем то, которое выше. Раз родитель тоже использует значение счётчика, то, следуя направлению потока данных сверху вниз, получается, что состояние должно быть у родителя, а дочерний компонент должен им пользоваться. Вот так будет правильно:

```javascript
// ---- файл App.js ----
import { useState } from 'react';
import { Counter } from './components/Counter';
import styles from './App.module.css';

const App = () => {
	const [value, setValue] = useState(0);

    return (
        <div className={styles.app}>
            <label>Счётчик ({value}):</label>
            <Counter value={value} onSetValue={setValue} />
        </div>
    );
}

export default App;
```

```javascript
// ---- файл /components/Counter.js ----
export const Counter = ({ value, onSetValue }) => {
	return (
		<>
			<div>{value}</div>
			<button onClick={() => onSetValue(value + 1)}>{value} + 1</button>
		</>
	);
};
```
Избавились от лишнего состояния в компоненте Counter и код сразу стал простым и понятным. Старайтесь всегда соблюдать правила Однонаправленного потока данных и Единого источника истины.

Насчёт хука useState() — он запоминает данные благодаря мемоизации. Это способность функции сохранять возвращаемые данные в память и использовать их, если функция вызывается с теми же параметрами. Наверное, звучит сложновато, в этом модуле не будем погружаться в детали этой темы. Добавлю только, что мемоизация позволяет оптимизировать работу приложения, не выполняя повторно вычисления, когда результат заведомо известен. По такому же принципу в React работают ещё 2 хука, которые как раз предназначены для оптимизации производительности. Это useMemo() и useCallback(). Мы поближе с ними познакомимся в уроке «10. Эпилог».

Промежуточные итоги

- Single Source of Truth (Единый источник истины) — это концепция управления состоянием, которая означает, что для одной цели следует использовать только один источник данных. Неконсистентные данные (не соответствующие друг другу) могут привести к сложной поддержке кода и ошибкам.
    
- Мемоизация — это способность функции сохранять результаты выполнения для заданных параметров и использовать их при повторных вызовах функции с теми же параметрами.